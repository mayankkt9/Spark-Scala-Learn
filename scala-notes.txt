



Scala Language Doc link  - https://www.scala-lang.org/api/2.13.2/

/*************** 1. Some Main Feature of Scala Programming ***************/


Some Features of Scala Programming 
	- Supports both Functional Programming and Object Oriented Programming
	- Immutable Object (Object whose state cant)
	- Referential Transparency (function replaced by its result)
Functional Programming is way of writing software application using only pure functions and 
immutable values.
Library design and data crunching problems (Read later)

/***************************************************************************/

/*************** 2. Types of Functions ***************/

Types of Functions
	- Pure Functions
	- Impure Functions
	- First Class Functions
	- Higher Order Functions
	- Anonymous Functions


 What functions are pure functions (Should statisfy all three approach)
 	- Input solely determines the output (There are no other global variable or any other input other than parameter that determines the output)
 	- The function doesnt change the input (Doesnt have pass by value or reference feature)
 	- The function doesnt do anything else except computing the output. (Doesnt change global variable state or do anything else)

If any function uses some global variable for calculation or changes global variable, this is an example of side effects in functions.
Pure functions are functions that doesnot have side effects.

How can we test if the function is the pure function 
	- Just test it for the referential Transparency.
	- That is replace the function references with the output value.

Why Pure Functions 
	- Encourages safe way of programming (No Surprises)
	- Composable or Modular (Function composition easy for pure functions)
	- Easy to test
	- Memoizable (Caching of deterministic functions) (Cache the results, compilers can also do that)
	- Can be lazy


First Class Function
	- All functions in Scala are First class functions
	- First Class Function follow these rules 
		- You can assign it to a variable 
		- You can pass it as an arguement to the other functions
		- You can return it as a value from other functions.
Higher Order functions
	- In Scala you can create higher order functions
	- Example map inbuilt functions in scala is a higher order function
	- Atlease one of these rules you should follow for higher order functions
		- Takes one or more functions as arguement
		- Return a function as its result


Anonymous Functions 
	- One time function

Example 

def getOps(c:Int) = (i:Int) => {
	val doubler = (x:Int) => {x*2}
	val tripler = (x:Int) => {x*3}
	if(c>0) doubler(i)
	else	tripler(i)
}

Instead for Clean Code you can do

def getOps(c:Int) = (i:Int) => {
	if(c>0) {i*2}
	else	{i*3}
}

val r = 1 to 10
r.map(getOps(-1))
r.map(getOps(1))

Benfit of Anonymous Functions
	- Instead of defining the whole function we can just write the body
	- More convinient to write and easy to use.

Signature and body of the code is function literal

Benefit of passing around functions
	- Abstraction is the main benefit of higher order function
	- Abstraction makes the program easily extendable
	- You communicate the behaviour and less the implementation
	- Abstracted the implementation detail under higher order function (Example shown down)
		- More Precise
		- East to Understand
		- More Reuse

Example 
Problem Statement - Remind all customer for payment

Imperative approach
for(Customer cust : CustList){
	remind(cust);
}

Functional Programming Higher order function (here forEach is an higher order function)
forEach(customer,remindPayment)
forEach(vendors,remindPayment)


Two types of Variable in Scala 
	- val (you cant change it)
	- var (You can change it)
Functional programming recommends you using val

Two Advantages of Immutability
	- Adopt Mathematical approach
	- Helps avoid various problems
		- immutable objects are more thread safe (Concurrent Programming)
		- data engineering 
	- Program without variable using recursions
		- Replace loops with recursion and avoid using vars.

We are not taking an oath to keep everything immutable
Mutability has its own advantages and we are free to choose what suites best for any problem
But for functional programming we should choose Immutability


Tail recursions

Yes, loops are better than recursion, because recursion takes lots of stack space.
Functional programming do involve lots of recursion so what is the solutions? 
Tail recursion is the solution
	- Function calling is what we do last in a function, such that no statement needs to be executed after that and so we dont have to come back after making each function call
	- Compiler will do the optimization internally
	- This optimization will overcome the performance and memory problem
def tailFact(n:Int,f:Int): Int={
	if(n<=0) return f
	else	return tailFact(n-1,n*f)
}

Functional Statement
	- Each statement returns a value
	- Even println returns a value
	- That is why some people say scala doesnt have statement it has expressions
	- It helps remove variable in our code, thus helping achieve Immutability
Example
def myResult(m:Int) = {
	if(m<=50) "passed"
	else	"failed"
}


Strict vs Lazy Evaluation

Strict - Evaluate the evaluation now
Lazy - Evalue it on the first use


Strict Evaluation
	- Variable Assignment
	- Functional parameter
	- Higher Order Functions

Variable Assignment
val s = fact(11)/fact(5)
This will be evaluated immediately and if we print s, fact function will not be called again
Just the assigned value would be printed.

Functional parameter
def functionCall(i:Int) = {
	println(i)
}
functionCall(fact(5)/fact(1))
Here first this value (fact(5)/fact(1)) will be calculated then it would be sent to function functionCall

Higher Order Function

def functionCall(f: => Int) = {
	f + f
}
functionCall(fact(5)/fact(1))
Here as we are sending the functions will be evaluated in this order that is two times each function
function fact(5) will be evaluated then
function fact(1) will be evaluated then
function fact(5) will be evaluated then
function fact(1) will be evaluated then
then the value of f + f will be returned i.e fact(5)/fact(1) + fact(5)/fact(1)

This is a performance issue, we can memoize this is functionCall function
def functionCall(f: => Int) = {
	println("Hello")
	val x = f
	x+x
}
fact functions will be evaluated first then Hello would be printed
Now each fact function fact(5) and fact(1) will be evaluated once.
But to note these were strict evaluation, where things were evaluated immediately

Strict Evaluation
	- Default evaluation in scala is strict
	- Scala evaluates function parameter before passing the value to a function. Hence they are evaluated only once.
		- Higher Order function are an exception that can be evaluated multiple times based on implementation
		- If you dont want multiple evaluation Cache it.

Lazy Evaluation (lazy keyword)

lazy val l = fact(5)/fact(2)
here fact will not be evaluated till the first use of l.
when we use l for the first time, these two fact functions will be evaluated.
If you use l from second time onwards, fact wont be evaluated further, instead value l assigned after first use will be used.


We can do the same lazy evaluation for Higher order function.
def functionCall(f: => Int) = {
	println("Hello")
	lazy val x = f
	x+x
}
functionCall(fact(5)/fact(1))
here first the function functionCall will be evaluated, when it sees the first f being used, then it calls fact function
Hello will be printed first and then fact will be called

Summary
	- Scala supports strict and lazy evaluation
	- default method is strict evaluation
	- You can even make a function lazy, by caching it to val.

Why Lazy ? 
	- To create Data Structure to handle large volumes of data efficiently
	- Apache Spark RDD they implement all operation lazy.

Example
Find first two error log in a file
val s = Source.fromFile("file.txt").getLines().toList.filter(_.contains("[error]")).take(2)

If your file is very large, you know this is not efficient because whole file would be traversed and converted to List
then each value int the list would be filtered and check for error contains and then you would take first two values.

Efficient Approch should be start from top as soon as you get two error logs stop.
val s = Source.fromFile("file.txt").getLines().toStream.filter(_.contains("[error]")).take(2)
When we create the stream it evaluated the first item, next item appears now as question mark meaning next item has not be evaluated till now.
Stream is a lazy data Structure and toStream is a lazy function, scala access the next line when it uses the next line.
s foreach println would give you the answer.


Pattern Matching
Matching object against object

There are many type of Pattern Matching one of them is 
	- Typed Pattern Matching (Object is of what type) (Very Basic Example)
Example
You have a requirement where you have to check whether two successive messages have same ID.

def testMessagePattern(l:List[Message]):String = {
   l match {
     case Nil => "Not found"
     case Message(EmailAddress(u1,d1),_) ::Message(EmailAddress(u2,d2),_) :: _ if(u1==u2) => u1 + " got two successive emails"
     case h::t => testMessagePattern(t)
   }
}
class Message(p_id:String, p_msg:String) {
  val id  = p_id;
  val msg = p_msg;
}
val messageList = List(
Message("tom@gmail.com","Message text 1"),
Message("7742394590","Message text 2"),
Message("8326192398","Message text 3"),
Message("lisa@gmail.com","Message text 4"),
Message("lisa@yahoo.com","Message text 5"),
Message("harry@gmail.com","Message text 6")
)
object EmailAddress {
  def apply(uname: String, dname: String) = uname + "@" + dname

  def unapply(str: String): Option[(String, String)] = {
      val parts = str split "@"
      if (parts.length == 2) Some(parts(0), parts(1)) else None
  }
}


Closure
	- Function
	- Pure or Impure
	- Named or Anonymous
	- uses one or more free variable in a function

Free variable are not part of the function arguement or defined locally
def getHike(salary:Double) = salary p/100
Here p is a free variable
Scala looks into the so-called nearest local lexical enviroment to find global variable p.
if p is defined locally then that p will be used otherwise you will get an error.
Closure takes the most recent state of the free variable.
Closure can be pure or impure based on var or val of free variable
If Closure changes free variable, changes persists outside closure


Functional vs OOP 
	- We create and pass function in FP
	- We create and pass objects in OOP
	- Objects are more flexible than function because they carry two elements methods and data elements.
	- So in FP how can we send data members and the methods, we can do that via Closure


Type System
	- If type checking done in compile time - Statically Typed (Scala)
	- If type checking done in run time - Dynamic Type (Python)
	- Statically Typed
		- Early Protection
		- Better Performance and optimization

Scala Type hierarchy
Any -> AnyVal,AnyRef
AnyVal -> Byte,Short,Int,Long,Float,Double,Char,Boolean,Unit
AnyRef -> List,Seq,Iterable,String

AnyVal -> Like primitives in Java but they are well defined classes in Scala
Scala Value classes dont need new keyword and are instantiated using literal
var x : Int = 123;
Unit is roughly like a void represented as empty parenthesis.
Implicit conversion of data type follow here too.
There are many more AnyVal subclasses like RichInt,RichBoolean.. (additional functionality)

AnyRef -> All Class written in Scala are part of this hierarchy
You can use new keyword to instantiate new object


Null and Nothing hierarchy
Any Ref Class <- Null <- Nothing
Any Val Class <- Nothing

Assigning null and nothing are not allowed for value classes
Assigning null is allowed for reference classes
Scala has automatic type inference 
val i = 5 + 3
making code short and precise
But it is mandatory to give type to function parameter.
def fun(i:Int) = i + 4
Here it also infer it return type as Int.
But in some scenario it cant do that - Recursive function


Scala is a pure OOP language as every value in a language is an Object (Integer,Double)

Operators
	- There are no operator in Scala
	- As all value are objects, each have function as their operator
	- Scala allows us to use the symbols as identifiers
	- Scala implements the arithmetic, logical, bitwise operators as methods
	- Every Method in scala is an operator (Important)
	- Scala allows Object Oriented Notation - Dot Notation as well as the opertor notation to call methods.
	- Four unary opertor in scala - +,-,~,!
Example

val i = 10
Calling via dot notation
i.*(5) gives 50 
i.compare(5) gives 5 
Calling via operator notation
i * 5 gives 50
i compare 5 gives 5

What if we have more than one input parameter ?
Ans - val r = 1 to (10,2)
Use Parenthesis

What if we have no parameter
Ans - println(-15 abs)


Scala Functions 

def myMax(x:Int,y:Int) : Int = {
	if(x>y)
		return x;
	else
		return y;
}

Things to note as to what all things are required and what are optional
	- Semicolon is optional
	- Return keyword is optional
	- Curly braces or single line body is optional
	- Return type is optional
	- = is must otherwise it would behave as a Unit return type.
Would look like
def myMax(x:Int,y:Int) = if(x>y) x else y

If you keep the parenthesis while defining a function you can call it with and without parenthesis
But if you remove the parenthesis while defining a function you can only call it without parenthesis
Use parenthesis when the function has a side effect 
When function does not have side effect use without parenthesis
Becuase thats a function a parameterless function with a parenthesis indicates a side effect.
