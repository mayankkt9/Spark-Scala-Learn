Scala Language Doc link  - https://www.scala-lang.org/api/2.13.2/


Some Features of Scala Programming 
	- Supports both Functional Programming and Object Oriented Programming
	- Immutable Object (Object whose state cant)
	- Referential Transparency (function replaced by its result)


 Functional Programming is way of writing software application using only pure functions and immutable values.

 library design and data crunching problems (Read later)


 What functions are pure functions (Should statisfy all three approach)
 	- Input solely determines the output (There are no other global variable or any other input other than parameter that determines the output)
 	- The function doesnt change the input (Doesnt have pass by value or reference feature)
 	- The function doesnt do anything else except computing the output. (Doesnt change global variable state or do anything else)

If any function uses some global variable for calculation or changes global variable, this is an example of side effects in functions.
Pure functions are functions that doesnot have side effects.

How can we test if the function is the pure function 
	- Just test it for the referential Transparency.
	- That is replace the function references with the output value.

Why Pure Functions 
	- Encourages safe way of programming (No Surprises)
	- Composable or Modular (Function composition easy for pure functions)
	- Easy to test
	- Memoizable (Caching of deterministic functions) (Cache the results, compilers can also do that)
	- Can be lazy


First Class Function
	- All functions in Scala are First class functions
	- First Class Function follow these rules 
		- You can assign it to a variable 
		- You can pass it as an arguement to the other functions
		- You can return it as a value from other functions.
Higher Order functions
	- In Scala you can create higher order functions
	- Example map inbuilt functions in scala is a higher order function
	- Atlease one of these rules you should follow for higher order functions
		- Takes one or more functions as arguement
		- Return a function as its result


Anonymous Functions 
	- One time function

Example 

def getOps(c:Int) = (i:Int) => {
	val doubler = (x:Int) => {x*2}
	val tripler = (x:Int) => {x*3}
	if(c>0) doubler(i)
	else	tripler(i)
}

Instead for Clean Code you can do

def getOps(c:Int) = (i:Int) => {
	if(c>0) {i*2}
	else	{i*3}
}

val r = 1 to 10
r.map(getOps(-1))
r.map(getOps(1))

Benfit of Anonymous Functions
	- Instead of defining the whole function we can just write the body
	- More convinient to write and easy to use.

Signature and body of the code is function literal

Benefit of passing around functions
	- Abstraction is the main benefit of higher order function
	- Abstraction makes the program easily extendable
	- You communicate the behaviour and less the implementation
	- Abstracted the implementation detail under higher order function (Example shown down)
		- More Precise
		- East to Understand
		- More Reuse

Example 
Problem Statement - Remind all customer for payment

Imperative approach
for(Customer cust : CustList){
	remind(cust);
}

Functional Programming Higher order function (here forEach is an higher order function)
forEach(customer,remindPayment)
forEach(vendors,remindPayment)


Two types of Variable in Scala 
	- val
	- var



