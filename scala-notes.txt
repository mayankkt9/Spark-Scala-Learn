Scala Language Doc link  - https://www.scala-lang.org/api/2.13.2/


Some Features of Scala Programming 
	- Supports both Functional Programming and Object Oriented Programming
	- Immutable Object (Object whose state cant)
	- Referential Transparency (function replaced by its result)


 Functional Programming is way of writing software application using only pure functions and immutable values.

 library design and data crunching problems (Read later)


 What functions are pure functions (Should statisfy all three approach)
 	- Input solely determines the output (There are no other global variable or any other input other than parameter that determines the output)
 	- The function doesnt change the input (Doesnt have pass by value or reference feature)
 	- The function doesnt do anything else except computing the output. (Doesnt change global variable state or do anything else)

If any function uses some global variable for calculation or changes global variable, this is an example of side effects in functions.
Pure functions are functions that doesnot have side effects.

How can we test if the function is the pure function 
	- Just test it for the referential Transparency.
	- That is replace the function references with the output value.

Why Pure Functions 
	- Encourages safe way of programming (No Surprises)
	- Composable or Modular (Function composition easy for pure functions)
	- Easy to test
	- Memoizable (Caching of deterministic functions) (Cache the results, compilers can also do that)
	- Can be lazy


First Class Function
	- All functions in Scala are First class functions
	- First Class Function follow these rules 
		- You can assign it to a variable 
		- You can pass it as an arguement to the other functions
		- You can return it as a value from other functions.
Higher Order functions
	- In Scala you can create higher order functions
	- Example map inbuilt functions in scala is a higher order function
	- Atlease one of these rules you should follow for higher order functions
		- Takes one or more functions as arguement
		- Return a function as its result


Anonymous Functions 
	- One time function

Example 

def getOps(c:Int) = (i:Int) => {
	val doubler = (x:Int) => {x*2}
	val tripler = (x:Int) => {x*3}
	if(c>0) doubler(i)
	else	tripler(i)
}

Instead for Clean Code you can do

def getOps(c:Int) = (i:Int) => {
	if(c>0) {i*2}
	else	{i*3}
}

val r = 1 to 10
r.map(getOps(-1))
r.map(getOps(1))

Benfit of Anonymous Functions
	- Instead of defining the whole function we can just write the body
	- More convinient to write and easy to use.

Signature and body of the code is function literal

Benefit of passing around functions
	- Abstraction is the main benefit of higher order function
	- Abstraction makes the program easily extendable
	- You communicate the behaviour and less the implementation
	- Abstracted the implementation detail under higher order function (Example shown down)
		- More Precise
		- East to Understand
		- More Reuse

Example 
Problem Statement - Remind all customer for payment

Imperative approach
for(Customer cust : CustList){
	remind(cust);
}

Functional Programming Higher order function (here forEach is an higher order function)
forEach(customer,remindPayment)
forEach(vendors,remindPayment)


Two types of Variable in Scala 
	- val (you cant change it)
	- var (You can change it)
Functional programming recommends you using val

Two Advantages of Immutability
	- Adopt Mathematical approach
	- Helps avoid various problems
		- immutable objects are more thread safe (Concurrent Programming)
		- data engineering 
	- Program without variable using recursions
		- Replace loops with recursion and avoid using vars.

We are not taking an oath to keep everything immutable
Mutability has its own advantages and we are free to choose what suites best for any problem
But for functional programming we should choose Immutability


Tail recursions

Yes, loops are better than recursion, because recursion takes lots of stack space.
Functional programming do involve lots of recursion so what is the solutions? 
Tail recursion is the solution
	- Function calling is what we do last in a function, such that no statement needs to be executed after that and so we dont have to come back after making each function call
	- Compiler will do the optimization internally
	- This optimization will overcome the performance and memory problem
def tailFact(n:Int,f:Int): Int={
	if(n<=0) return f
	else	return tailFact(n-1,n*f)
}

Functional Statement
	- Each statement returns a value
	- Even println returns a value
	- That is why some people say scala doesnt have statement it has expressions
	- It helps remove variable in our code, thus helping achieve Immutability
Example
def myResult(m:Int) = {
	if(m<=50) "passed"
	else	"failed"
}


Strict vs Lazy Evaluation

Strict - Evaluate the evaluation now
Lazy - Evalue it on the first use


Strict Evaluation
	- Variable Assignment
	- Functional parameter
	- Higher Order Functions

Variable Assignment
val s = fact(11)/fact(5)
This will be evaluated immediately and if we print s, fact function will not be called again
Just the assigned value would be printed.

Functional parameter
def functionCall(i:Int) = {
	println(i)
}
functionCall(fact(5)/fact(1))
Here first this value (fact(5)/fact(1)) will be calculated then it would be sent to function functionCall

Higher Order Function

def functionCall(f: => Int) = {
	f + f
}
functionCall(fact(5)/fact(1))
Here as we are sending the functions will be evaluated in this order that is two times each function
function fact(5) will be evaluated then
function fact(1) will be evaluated then
function fact(5) will be evaluated then
function fact(1) will be evaluated then
then the value of f + f will be returned i.e fact(5)/fact(1) + fact(5)/fact(1)

This is a performance issue, we can memoize this is functionCall function
def functionCall(f: => Int) = {
	println("Hello")
	val x = f
	x+x
}
fact functions will be evaluated first then Hello would be printed
Now each fact function fact(5) and fact(1) will be evaluated once.
But to note these were strict evaluation, where things were evaluated immediately

Strict Evaluation
	- Default evaluation in scala is strict
	- Scala evaluates function parameter before passing the value to a function. Hence they are evaluated only once.
		- Higher Order function are an exception that can be evaluated multiple times based on implementation
		- If you dont want multiple evaluation Cache it.

Lazy Evaluation (lazy keyword)

lazy val l = fact(5)/fact(2)
here fact will not be evaluated till the first use of l.
when we use l for the first time, these two fact functions will be evaluated.
If you use l from second time onwards, fact wont be evaluated further, instead value l assigned after first use will be used.


We can do the same lazy evaluation for Higher order function.
def functionCall(f: => Int) = {
	println("Hello")
	lazy val x = f
	x+x
}
functionCall(fact(5)/fact(1))
here first the function functionCall will be evaluated, when it sees the first f being used, then it calls fact function
Hello will be printed first and then fact will be called

Summary
	- Scala supports strict and lazy evaluation
	- default method is strict evaluation
	- You can even make a function lazy, by caching it to val.

Why Lazy ? 
	- To create Data Structure to handle large volumes of data efficiently
	- Apache Spark RDD they implement all operation lazy.

Example
Find first two error log in a file
val s = Source.fromFile("file.txt").getLines().toList.filter(_.contains("[error]")).take(2)

If your file is very large, you know this is not efficient because whole file would be traversed and converted to List
then each value int the list would be filtered and check for error contains and then you would take first two values.

Efficient Approch should be start from top as soon as you get two error logs stop.
val s = Source.fromFile("file.txt").getLines().toStream.filter(_.contains("[error]")).take(2)
When we create the stream it evaluated the first item, next item appears now as question mark meaning next item has not be evaluated till now.
Stream is a lazy data Structure and toStream is a lazy function, scala access the next line when it uses the next line.
s foreach println would give you the answer.


Pattern Matching

